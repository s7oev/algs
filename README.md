# Princeton's Algorithms
s7oev/algs is my proof that I have finished the courses **Algorithms, Part I** and **Algorithms, Part II**. Both are available on Coursera ([P1](https://www.coursera.org/learn/algorithms-part1), [P2](https://www.coursera.org/learn/algorithms-part2)), and together form the equivalent of Princeton's on-campus algorithms course: COS226. You can read [my review of the course on my blog](https://s7oev.com/blog/2020/05/24/my-review-of-princetons-algorithms/).

**Do note that I'm following the course's honor code and not sharing publically the solutions to the programming assignments**. So, this repository contains my solutions, however, they are in **password-protected** ZIP archives. If you have a valid reason for wanting to check out my code, email me on stoikostoev12345@gmail.com! Besides this, publically available are the output of the graders for my solutions, the assignments themselves, and a screenshot of the submission pages for the assignments (to monitor how my grades progress).

The folders have the following structure:
* **_(assignment name)-encrypted.zip_** :: my solution (password-protected)
* **_(assignment name)-assignment.pdf_** :: the assignment specification from Princeton, printed to PDF
* **_(assignment name)-grader-output.txt_** :: the automated grader's feedback on my best submission
* **_(assignment name)-submission-page.pdf_** :: Coursera's submission page for the assignment showing my grade progress

# Syllabus
## Part I
### Week 1
| Topic | Contents |
| ------ | ------ |
| Union-Find | Dynamic Connectivity, Quick Find, Quick Union, Quick-Union Improvements, Union−Find Applications|
| Analysis of Algorithms | Analysis of Algorithms Introduction, Observations, Mathematical Models, Order-of-Growth Classifications, Theory of Algorithms, Memory|
| Assignment 1: Percolation | Write a program to estimate the value of the percolation threshold via Monte Carlo simulation|

### Week 2
| Topic | Contents |
| ------ | ------ |
| Stacks and Queues | Stacks, Resizing Arrays, Queues, Generics, Iterators, Stack and Queue Applications (optional)|
| Elementary Sorts | Sorting Introduction, Selection Sort, Insertion Sort, Shellsort, Shuffling, Convex Hull|
| Assignment 2: Queues | Write a generic data type for a deque and a randomized queue. The goal of this assignment is to implement elementary data structures using arrays and linked lists, and to introduce you to generics and iterators|

### Week 3
| Topic | Contents |
| ------ | ------ |
| Mergesort | Mergesort, Bottom-up Mergesort, Sorting Complexity, Comparators, Stability|
| Quicksort | Quicksort, Selection, Duplicate Keys, System Sorts|
| Assignment 3: Collinear Points | Computer vision involves analyzing patterns in visual images and reconstructing the real-world objects that produced them. The process is often broken up into two phases: feature detection and pattern recognition. Feature detection involves selecting important features of the image; pattern recognition involves discovering patterns in the features. We will investigate a particularly clean pattern recognition problem involving points and line segments. This kind of pattern recognition arises in many other applications such as statistical data analysis|

### Week 4
| Topic | Contents |
| ------ | ------ |
| Priority Queues | APIs and Elementary Implementations, Binary Heaps, Heapsort, Event-Driven Simulation (optional)|
| Elementary Symbol Tables | Symbol Table API, Elementary Implementations, Ordered Operations, Binary Search Trees, Ordered Operations in BSTs, Deletion in BSTs|
| Assignment 4: Slider Puzzle | Write a program to solve the 8-puzzle problem (and its natural generalizations) using the A* search algorithm|

### Week 5
| Topic | Contents |
| ------ | ------ |
| Balanced Search Trees | 2−3 Search Trees, Red-Black BSTs, B-Trees (optional)|
| Geometric Applications of BSTs | 1d Range Search, Line Segment Intersection, Kd-Trees, Interval Search Trees, Rectangle Intersection|
| Assignment 5: KD-Trees | Write a data type to represent a set of points in the unit square (all points have x- and y-coordinates between 0 and 1) using a 2d-tree to support efficient range search (find all of the points contained in a query rectangle) and nearest-neighbor search (find a closest point to a query point). 2d-trees have numerous applications, ranging from classifying astronomical objects to computer animation to speeding up neural networks to mining data to image retrieval|

### Week 6
| Topic | Contents |
| ------ | ------ |
| Hash Tables | Hash Tables, Separate Chaining, Linear Probing, Hash Table Context|
| Symbol Table Applications | Symbol Table Applications: Sets (optional), Symbol Table Applications: Dictionary Clients (optional), Symbol Table Applications: Indexing Clients (optional), Symbol Table Applications: Sparse Vectors (optional)|
